<<<<<<< HEAD
var tipuesearch = {"pages": [{'title': 'About..', 'text': '2b2- pj2bg8 \n \n 倉儲:\xa0 https://github.com/mdecd2023/2b2-pj2bg8 \n 網站連結:\xa0 https://mdecd2023.github.io/2b2-pj2bg8/content/index.html \n 人員 \n 41023202 ting0111 \n 41023212 yonqui0411 \n 41023229 CHI1020 \n 41023242 41023242 \n \n https://mde.tw/pjcopsim \n', 'tags': '', 'url': 'About...html'}, {'title': 'w9', 'text': '', 'tags': '', 'url': 'w9.html'}, {'title': '41023202-1', 'text': '轉檔過程 41023202 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n football STL檔 \n \n', 'tags': '', 'url': '41023202-1.html'}, {'title': '41023212-1', 'text': '心得:這次是請教同學，學到了怎麼自查ip位置和如何使用於課程教材，且更了解關於CoppeliaSim的技巧 \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': '41023212-1.html'}, {'title': '41023229-1', 'text': '\n \n \n \n 心得:這次機器人的操做可以手動控制，連線比之前還要複雜難懂，繼續加油。 \n', 'tags': '', 'url': '41023229-1.html'}, {'title': '41023242-1', 'text': '\n 這是機器人是可以由兩台電腦連線控制的，IP要一樣，有時會發生連不到線的問題，經由老師和同學的教導後也更熟悉remoteapi \n', 'tags': '', 'url': '41023242-1.html'}, {'title': 'w10', 'text': '41023202:試著理解老師的題目以及幫助組長做的。 \n \n 41023229:了解老師的題目， \n 41023242:詢問同學協助組長，尋找Bython程式問題 \n \n 41023212製作亂數抽組。 \n 亂數 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  亂數 開始  \n \n \n  亂數 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n \n', 'tags': '', 'url': 'w10.html'}, {'title': '有關CoppeliaSim zmpRemoteAPI', 'text': '1.What is zmqRemoteAPI, and how does it relate to CoppeliaSim? zmqRemoteAPI是一種消息傳遞協議，使用ZeroMQ消息庫在網路上實現不同進程或電腦之間的通訊。它被用於CoppeliaSim這個流行的機器人仿真軟體中，提供了一種遠端應用程式編程介面（API），使得使用者可以用不同的程式語言控制和與仿真環境交互。 換句話說，zmqRemoteAPI提供了一種外部程式與CoppeliaSim通訊的方式，允許使用者控制仿真環境、發送命令到機器人和傳感器，並從仿真中檢索資料。這使得可以創建使用CoppeliaSim作為仿真引擎的自定義應用程式，從而實現更先進的機器人研究和開發。 zmqRemoteAPI提供同步和非同步兩個版本，允許使用者根據自己的需要選擇適當的方法。同步版本允許輕鬆集成支援同步通訊的程式語言，而非同步版本則允許與CoppeliaSim進行更靈活和高效的通訊。 總的來說，zmqRemoteAPI是CoppeliaSim的一個重要特性，使得與其他軟體的集成變得容易，同時也使得機器人研究和開發變得更加先進。 \n 2.How do you establish a connection between a Python script and CoppeliaSim using zmqRemoteAPI? 使用zmqRemoteAPI建立Python腳本和CoppeliaSim之間的連接需要完成以下步驟： 在CoppeliaSim中啟用遠程API功能：在CoppeliaSim的“選項”菜單中，勾選“遠程API服務器”。確定設置無誤後，重新啟動CoppeliaSim。 在Python中安裝pyzmq庫：使用pip命令安裝pyzmq庫，以便在Python腳本中使用zmqRemoteAPI。 編寫Python腳本：編寫Python腳本以使用zmqRemoteAPI與CoppeliaSim進行通訊。首先，創建一個zmq.Context對象，然後創建一個zmq.REQ（要求）套接字，並使用connect()方法將套接字連接到CoppeliaSim的遠程API服務器地址。 通訊：使用zmq.REQ套接字向CoppeliaSim發送請求。zmq.REQ套接字使用send()方法發送二進制數據，並使用recv()方法接收CoppeliaSim的回應數據。發送和接收的消息格式需要按照zmqRemoteAPI文檔的規定進行編碼和解碼。 總的來說，通過上述步驟可以使用Python腳本與CoppeliaSim進行通訊，實現對機器人仿真環境的控制和數據交換。 \n 3.What are some common use cases for zmqRemoteAPI in CoppeliaSim? zmqRemoteAPI在CoppeliaSim中有許多常見的用例，下面列出其中幾個： 機器人控制：使用zmqRemoteAPI，可以在Python、C++等程式語言中編寫控制機器人的代碼，並通過與CoppeliaSim的通訊將其應用於仿真環境中。這使得可以測試機器人的運動、感知和控制算法，並且可以與實際硬體進行比較。 軌跡規劃：通過zmqRemoteAPI，可以在Python中使用各種規劃算法計算機器人的運動軌跡，然後將軌跡傳遞給CoppeliaSim以顯示機器人的運動軌跡。 场景控制：可以使用zmqRemoteAPI對CoppeliaSim的場景進行控制，例如更改場景中物體的位置、旋轉角度、添加新的物體等等。這使得可以創建自定義的仿真場景，並且可以測試機器人在不同環境下的表現。 資料檢索：使用zmqRemoteAPI，可以從CoppeliaSim中獲取各種資料，例如機器人的位置、速度、傳感器數據等等。這對於監控仿真運行狀態、測試算法的性能等都非常有用。 總的來說，zmqRemoteAPI在CoppeliaSim中被廣泛應用，可用於各種機器人研究和開發場景，使得使用者可以更輕鬆地控制仿真環境，並進行各種測試和分析。 \n 4.What are the advantages and disadvantages of using zmqRemoteAPI compared to other methods of communication between Python and CoppeliaSim? 使用zmqRemoteAPI與其他Python與CoppeliaSim之間的通訊方式相比，有以下優點和缺點： 優點： 快速：zmqRemoteAPI使用ZeroMQ庫，通訊速度較快，能夠實現快速的數據傳輸。 靈活性：使用zmqRemoteAPI可以實現很多不同的通訊方式，例如請求/回應、訂閱/發布等等，可以根據不同的應用場景選擇不同的通訊模式。 可擴展性：zmqRemoteAPI具有良好的可擴展性，能夠支持多種用戶同時連接到CoppeliaSim，並且能夠支持多種操作系統。 跨平台：zmqRemoteAPI適用於各種操作系統和平台，使得不同的環境下使用者都可以輕鬆地進行通訊。 缺點： 學習曲線：使用zmqRemoteAPI需要學習一些新的概念和API，對於初學者來說可能需要花費一些時間來學習。 程式代碼複雜：使用zmqRemoteAPI時需要在Python代碼中編寫很多低層次的通訊代碼，這可能會使代碼變得複雜。 總的來說，zmqRemoteAPI是一種可靠且快速的通訊方式，並且具有良好的可擴展性和跨平台性，但使用它需要一定的學習和編程知識。 \n 5.Can you give an example of a project or task that you could complete using zmqRemoteAPI in CoppeliaSim? 以下是使用zmqRemoteAPI在CoppeliaSim中完成的一些項目示例： 機器人運動控制：使用zmqRemoteAPI可以通過Python腳本控制CoppeliaSim中的機器人運動，從而實現各種自動化任務，例如導航、定位、抓取等。 场景仿真：使用zmqRemoteAPI可以在CoppeliaSim中進行場景仿真，並通過Python腳本控制仿真參數、物體位置、燈光等，從而實現各種場景測試和仿真。 機器人視覺感知：使用zmqRemoteAPI可以通過Python腳本控制CoppeliaSim中的機器人視覺感知模塊，從而實現物體檢測、識別、追蹤等任務。 自主車輛控制：使用zmqRemoteAPI可以通過Python腳本控制CoppeliaSim中的自主車輛運動，從而實現路徑規劃、障礙物避免、速度控制等任務。 總之，使用zmqRemoteAPI可以實現各種不同的任務和項目，並且具有良好的可擴展性和靈活性。 \n', 'tags': '', 'url': '有關CoppeliaSim zmpRemoteAPI.html'}, {'title': 'W11', 'text': '場地 \n 計分器(完整版) \n zmqRemoteAPI Python 操控含場景 (.7z連結) \n /downloads/足球遊戲(分).ttt \n \n 計分器(錯誤版) \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n 遇到的問題:其中一邊的感測線會自己跑動導致觸碰到球框得分 \n 半成品 \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n 問題回報:得分後球的傳感器會回到原點 \n \n', 'tags': '', 'url': 'W11.html'}, {'title': '41023202-2', 'text': '心得: \n 這次跟了組員一起做了感測器、場地、記分板，圖修修改改了許多次。也測試了許多次。其中推的過程也發生許多問題，但最後也都解決了。過程也與組員詢問別組的同學，一起完成作業，之後也會繼續努力的。 \n 自評分數:60 \n', 'tags': '', 'url': '41023202-2.html'}, {'title': '41023212-2', 'text': '自評: \n 正在持續碰到問題與解決問題，遇到不會的問題會請教會的同學 \n 分數: \n 60 \n', 'tags': '', 'url': '41023212-2.html'}, {'title': '41023229-2', 'text': '心得: \n 做了許多測試，遇到了很多困難，不會的問那些比較厲害的同學。請他們教我如何製作。 \n 自評分數:50 \n', 'tags': '', 'url': '41023229-2.html'}, {'title': '41023242-2', 'text': '心得:這次我分別做了感測器、場地、記分板，一開始設定感測器range時不小心設得太大卡在牆壁裡，導致分數直接破表，後來把range調小之後便可以正常遊戲，場地的部分按開始時會到處亂跑，經過同學指導後，發現場地畫的太低了，所以我直接把場地由Z軸調高，在測試的時候有遇到一個問題，就是球進門的時候球不會回到場地內，所以我做了一些程式的修改，修改後就正常了，其實在場地的部分我畫了很久，我一開始的場地是有畫地板的，導致開始的時候場地會不明的抖動相當詭異，後來試著不要畫地板看看，果然沒了地板之後場地的部分也就正常了，這次的足球機器人花了不少時間，在這其中遇到了許多的困難，也謝謝老師與同學們的耐心教導，我以後一定會繼續努力的。 \n 自評分數:70 \n', 'tags': '', 'url': '41023242-2.html'}, {'title': 'Brython', 'text': '\n https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍) \n Variables ( Python Keywords ) \n Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解) \n Numbers  (整數 int(), 浮點數 float()) \n Strings  (字串) \n print (Python 內建函式,  print()  函式) \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': 'Brython.html'}, {'title': 'Brython_ex2', 'text': 'This code uses the Euler method to approximate the solution to the ODE dy/dx = x - y with an initial condition of y0 = 1.0. The solution is calculated for a range of x values from 0 to 5. \n \n \n \n \n \n \n Solve ODE: \n from browser import document\n\ndef dy_dx(y, x):\n    return x - y\n\nx_start = 0\nx_end = 5\nn_points = 100\nx = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]\ny0 = 1.0\nh = x[1] - x[0]\ny = [y0]\nfor i in range(1, len(x)):\n    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))\n\n# Create a new paragraph element and set its text content to the solution\np = document.createElement(\'p\')\np.textContent = f"The solution to the ODE is: {y}"\n\n# Append the paragraph element to the body of the webpage\ndocument.body.appendChild(p) \n \n \n \n \n \n Brython environment and  Plotly.js : \n <script src="./../cmsimde/static/brython.js"></script>\n<script src="./../cmsimde/static/brython_stdlib.js"></script>\n<script>// <![CDATA[\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\']});\n}\n// ]]></script>\n<p id="brython_div"></p> \n Brython programe with Plotly.js: \n from browser import document, window\n\ndef dy_dx(y, x):\n    return x - y\n\nx_start = 0\nx_end = 5\nn_points = 100\nx = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]\ny0 = 1.0\nh = x[1] - x[0]\ny = [y0]\nfor i in range(1, len(x)):\n    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))\n\n# Create a new div element to hold the plot\n#plot_div = document.createElement(\'div\')\n#plot_div.id = \'plot\'\n#document.body.appendChild(plot_div)\nplot_div = document["brython_div"]\n\n# Plot the solution using plotly.js\ndata = [{\'x\': x, \'y\': y}]\nwindow.Plotly.newPlot(\'brython_div\', data) \n This code defines a function dy_dx that represents the mass-spring-damper ordinary differential equation. The Euler method is used to solve this equation for a range of x values from 0 to 20 with initial conditions of y0 = [1.0, 0.0]. The solution is then plotted on the webpage using  plotly.js . \n \n \n \n \n This code defines a function dy_dx that represents the mass-spring-damper system with a PID controller. The gains of the PID controller are set to Kp = 10.0, Ki = 1.0, and Kd = 0.5. The Euler method is used to solve this system of equations for a range of x values from 0 to 20 with initial conditions of y0 = [0.0, 0.0, 0.0, 0.0]. The response of the system is then plotted on the webpage using  plotly.js . \n \n \n \n \n \n \n \n \n \n \n \n \n \n STL part viewer \n \n \n \n \n Using  sine-cosine algorithm  to optimize with constraints in Brython: \n <!DOCTYPE html>\n<html>\n<head>\n    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython_stdlib"></script>\n</head>\n<body onload="brython()">\n\n<div id="output"></div>\n\n<script type="text/python">\nfrom browser import document\nfrom random import random, uniform\nfrom math import sin, cos, pi\n\n# Define the objective function\ndef objective_function(x):\n    return x[0]**2 + x[1]**2\n\n# Define the constraint functions\ndef constraint1(x):\n    return x[0] + x[1] - 2\n\ndef constraint2(x):\n    return 1 - x[0] - x[1]\n\n# Define the penalty function\ndef penalty_function(x):\n    penalty = 0\n    if constraint1(x) > 0:\n        penalty += constraint1(x)\n    if constraint2(x) > 0:\n        penalty += constraint2(x)\n    return penalty\n\n# Define the fitness function\ndef fitness_function(x):\n    return objective_function(x) + penalty_function(x)\n\n# Define the sine cosine algorithm\ndef sine_cosine_algorithm(fitness_function, dimension, lower_bound, upper_bound, population_size, max_iterations):\n    # Initialize the population\n    population = [[uniform(lower_bound, upper_bound) for _ in range(dimension)] for _ in range(population_size)]\n    population_fitness = [fitness_function(individual) for individual in population]\n\n    # Initialize the best solution\n    best_solution = population[0]\n    best_fitness = population_fitness[0]\n\n    # Main loop of the algorithm\n    for iteration in range(max_iterations):\n        # Calculate the value of a and r1\n        a = 2 - iteration * (2 / max_iterations)\n        r1 = 2 * pi * random()\n\n        # Update the population\n        for i in range(population_size):\n            # Calculate the value of r2, r3 and r4\n            r2 = 2 * random()\n            r3 = 2 * random()\n            r4 = random()\n\n            # Update the individual\n            for j in range(dimension):\n                if r4 < 0.5:\n                    population[i][j] += r1 * sin(r2) * abs(r3 * best_solution[j] - population[i][j])\n                else:\n                    population[i][j] += r1 * cos(r2) * abs(r3 * best_solution[j] - population[i][j])\n\n                # Make sure the individual is within the bounds\n                if population[i][j] < lower_bound:\n                    population[i][j] = lower_bound\n                elif population[i][j] > upper_bound:\n                    population[i][j] = upper_bound\n\n            # Calculate the fitness of the individual\n            population_fitness[i] = fitness_function(population[i])\n\n            # Update the best solution\n            if population_fitness[i] < best_fitness:\n                best_solution = population[i]\n                best_fitness = population_fitness[i]\n\n        # Print the current iteration and best fitness\n        print(f\'Iteration: {iteration + 1}, Best Fitness: {best_fitness:.6f}\')\n\n    return best_solution\n\n# Run the sine cosine algorithm to solve the optimization problem with constraints\nbest_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100)\n\n# Print the result\noutput_div = document[\'output\']\noutput_div.text = f\'Best Solution: {best_solution}\'\n</script>\n\n<script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"></script>\n</body>\n</html> \n Plot the result by using  plotly.js : \n <!DOCTYPE html>\n<html>\n<head>\n    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython_stdlib"></script>\n    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>\n</head>\n<body onload="brython()">\n\n<div id="output"></div>\n<div id="plot"></div>\n\n<script type="text/python">\nfrom browser import document\nfrom random import random, uniform\nfrom math import sin, cos, pi\n\n# Define the objective function\ndef objective_function(x):\n    return x[0]**2 + x[1]**2\n\n# Define the constraint functions\ndef constraint1(x):\n    return x[0] + x[1] - 2\n\ndef constraint2(x):\n    return 1 - x[0] - x[1]\n\n# Define the penalty function\ndef penalty_function(x):\n    penalty = 0\n    if constraint1(x) > 0:\n        penalty += constraint1(x)\n    if constraint2(x) > 0:\n        penalty += constraint2(x)\n    return penalty\n\n# Define the fitness function\ndef fitness_function(x):\n    return objective_function(x) + penalty_function(x)\n\n# Define the sine cosine algorithm\ndef sine_cosine_algorithm(fitness_function, dimension, lower_bound, upper_bound, population_size, max_iterations):\n    # Initialize the population\n    population = [[uniform(lower_bound, upper_bound) for _ in range(dimension)] for _ in range(population_size)]\n    population_fitness = [fitness_function(individual) for individual in population]\n\n    # Initialize the best solution\n    best_solution = population[0]\n    best_fitness = population_fitness[0]\n\n    # Main loop of the algorithm\n    for iteration in range(max_iterations):\n        # Calculate the value of a and r1\n        a = 2 - iteration * (2 / max_iterations)\n        r1 = 2 * pi * random()\n\n        # Update the population\n        for i in range(population_size):\n            # Calculate the value of r2, r3 and r4\n            r2 = 2 * random()\n            r3 = 2 * random()\n            r4 = random()\n\n            # Update the individual\n            for j in range(dimension):\n                if r4 < 0.5:\n                    population[i][j] += r1 * sin(r2) * abs(r3 * best_solution[j] - population[i][j])\n                else:\n                    population[i][j] += r1 * cos(r2) * abs(r3 * best_solution[j] - population[i][j])\n\n                # Make sure the individual is within the bounds\n                if population[i][j] < lower_bound:\n                    population[i][j] = lower_bound\n                elif population[i][j] > upper_bound:\n                    population[i][j] = upper_bound\n\n            # Calculate the fitness of the individual\n            population_fitness[i] = fitness_function(population[i])\n\n            # Update the best solution\n            if population_fitness[i] < best_fitness:\n                best_solution = population[i]\n                best_fitness = population_fitness[i]\n\n        # Print the current iteration and best fitness\n        print(f\'Iteration: {iteration + 1}, Best Fitness: {best_fitness:.6f}\')\n\n    return best_solution\n\n# Run the sine cosine algorithm to solve the optimization problem with constraints\nbest_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100)\n\n# Print the result\noutput_div = document[\'output\']\noutput_div.text = f\'Best Solution: {best_solution}\'\n\n# Plot the result using Plotly.js\ndata = [\n    {\n        \'x\': [best_solution[0]],\n        \'y\': [best_solution[1]],\n        \'mode\': \'markers\',\n        \'marker\': {\'size\': 12},\n        \'name\': \'Best Solution\'\n    }\n]\n\nlayout = {\n    \'xaxis\': {\'range\': [-10, 10]},\n    \'yaxis\': {\'range\': [-10, 10]},\n}\n\nPlotly.newPlot(\'plot\', data, layout)\n</script>\n\n<script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"></script>\n</body>\n</html> \n \n function(population[i]) # Update the best solution if population_fitness[i] < best_fitness: best_solution = population[i] best_fitness = population_fitness[i] # Print the current iteration and best fitness print(f\'Iteration: {iteration + 1}, Best Fitness: {best_fitness:.6f}\') return best_solution # Run the sine cosine algorithm to solve the optimization problem with constraints best_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100) # Print the result output_div = document[\'output\'] output_div.text = f\'Best Solution: {best_solution}\' # Plot the result using Plotly.js data = [ { \'x\': [best_solution[0]], \'y\': [best_solution[1]], \'mode\': \'markers\', \'marker\': {\'size\': 12}, \'name\': \'Best Solution\' } ] layout = { \'xaxis\': {\'range\': [-10, 10]}, \'yaxis\': {\'range\': [-10, 10]}, } Plotly.newPlot(\'plot\', data, layout) </script> <script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"></script> </body> </html> \n', 'tags': '', 'url': 'Brython_ex2.html'}]};
=======
var tipuesearch = {"pages": [{'title': 'Home', 'text': '組員: \n 40923115 吳圳吉 帳號:jason60714 \n 40923235 40923235 \n 40923130 Martin3130 \n \n 倉庫: \n \xa0 \xa0 \xa0   https://github.com/mdecd2023/2b2-pj2bg15 \n 網站： \n \xa0 \xa0 \xa0   https://mdecd2023.github.io/2b2-pj2bg15/content/index.html \n \n', 'tags': '', 'url': 'Home.html'}, {'title': 'w9h1', 'text': '', 'tags': '', 'url': 'w9h1.html'}, {'title': '40923115', 'text': '今天重新分組，然後clone新的作業。 \n', 'tags': '', 'url': '40923115.html'}, {'title': '40923130', 'text': '今天的作業是利用鍵盤來控制，對我來說是個很好的幫助，在tutorial1中，我有試試詢問ChatGPT教我寫鍵盤控制的程式碼，但程式碼有些問題，到目前都還沒有成功，所以這個對我來說非常有幫助。 \n', 'tags': '', 'url': '40923130.html'}, {'title': '40923235', 'text': '\n 創建新的靜態，途中遇到 \n 解決方法:資料夾名稱不得為中文。 \n \n', 'tags': '', 'url': '40923235.html'}, {'title': 'W10', 'text': '工作分配  \n 40923130:寫Brython 程式 \n 40923115:尋找與回答Teams問題 \n 40923235:尋找與回答Teams問題 \n \n  導入 brython 程式庫  \n \n \n  啟動 Brython  \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  印出版次與關鍵字程式  \n \n \n \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  Filename:  .py    存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div 作為切入位置  \n \n \n \n', 'tags': '', 'url': 'W10.html'}, {'title': '有關 CoppeliaSim zmqRemoteAPI 問題', 'text': 'Q1. \n What is zmqRemoteAPI, and how does it relate to CoppeliaSim? \n Ans. \n zmqRemoteAPI 是一個基於 ZeroMQ 的遠程 API 通訊協議，用於在不同的程序之間進行通訊和數據傳輸。它被廣泛地應用在機器人控制、自動化系統和科學模擬等領域中。 \n CoppeliaSim 是一個功能強大的機器人仿真軟件，可以模擬各種機器人和自動化系統的行為和控制。它支持多種編程語言和通訊協議，包括 zmqRemoteAPI。 \n 在 CoppeliaSim 中，使用者可以通過遠程 API 與 CoppeliaSim 進行交互，控制機器人或自動化系統的運動、感測器和設備的狀態，並且可以獲取仿真數據和視頻流。而 zmqRemoteAPI 就是其中一種可用的遠程 API 通訊協議，它可以讓使用者通過 ZeroMQ 協議與 CoppeliaSim 進行通訊和數據傳輸，實現對 CoppeliaSim 中機器人和自動化系統的控制和監控。 \n Q2. \n How do you establish a connection between a Python script and CoppeliaSim using zmqRemoteAPI? \n Ans. \n \n \n 在 CoppeliaSim 中啟用 zmqRemoteAPI。在 CoppeliaSim 中，單擊菜單中的“File”->“Preferences”->“Remote API”，勾選“Enable the remote API server”選項，選擇“ZeroMQ”通訊協議，然後保存並關閉偏好設置。 \n \n \n 在 Python 環境中安裝 pyzmq 模塊。可以使用 pip 安裝 pyzmq 模塊，命令為“pip install pyzmq”。 \n \n \n 在 Python 腳本中創建 ZeroMQ socket 對象。可以使用 pyzmq 提供的 zmq.Context() 方法創建一個 ZeroMQ 的上下文對象，然後使用該對象的 socket() 方法創建一個 socket 對象。 \n \n \n 通過 socket 對象向 CoppeliaSim 發送遠程 API 請求。可以使用 socket 對象的 send_string() 方法向 CoppeliaSim 發送包含遠程 API 請求命令的字符串，然後等待 CoppeliaSim 返回結果。 \n \n \n 解析 CoppeliaSim 返回的結果。可以使用 socket 對象的 recv() 方法接收 CoppeliaSim 返回的數據，然後解析數據以獲取所需的信息。 \n \n \n Q3. \n What are some common use cases for zmqRemoteAPI in CoppeliaSim? \n Ans. \n \n \n 控制機器人或自動化系統的運動：使用者可以通過 zmqRemoteAPI 向 CoppeliaSim 發送控制指令，使得機器人或自動化系統按照所需的運動軌跡進行運動。這個功能在機器人控制、自動化系統測試等方面都有廣泛的應用。 \n \n \n 監控機器人或自動化系統的狀態：使用者可以通過 zmqRemoteAPI 得到機器人或自動化系統的狀態信息，例如位置、速度、加速度、姿態等，以實現對機器人或自動化系統的監控和調試。 \n \n \n 模擬感測器和設備的輸出：使用者可以通過 zmqRemoteAPI 模擬感測器和設備的輸出，例如激光測距儀、攝像頭、輸送帶等，以測試和驗證控制算法的有效性和穩定性。 \n \n \n 執行複雜仿真實驗：使用者可以通過 zmqRemoteAPI 在 CoppeliaSim 中建立複雜的仿真場景和實驗，例如多機器人協作、自主導航、物體檢測和識別等，以驗證和優化自主系統的性能和效果。 \n \n \n Q4. \n What are the advantages and disadvantages of using zmqRemoteAPI compared to other methods of communication between Python and CoppeliaSim? \n Ans. \n 優點： \n \n \n 簡單易用：zmqRemoteAPI 提供了一個簡單而易用的接口，使得使用者可以輕鬆地在 Python 腳本和 CoppeliaSim 之間進行通訊和控制。 \n \n \n 快速高效：zmqRemoteAPI 使用 ZeroMQ 通訊協議，可以實現快速高效的數據傳輸，對於需要高頻率、高實時性的控制和監控操作非常適用。 \n \n \n 靈活可擴展：zmqRemoteAPI 提供了多種不同的遠程 API 接口，可以實現多種不同的功能和應用場景，並且支持 Python 和其他編程語言的集成，具有良好的可擴展性。 \n \n \n 缺點： \n \n \n 依賴特定庫：zmqRemoteAPI 使用 pyzmq 库實現 ZeroMQ 通訊協議，需要在 Python 環境中安裝相應的庫和依賴，增加了使用的門檻和複雜度。 \n \n \n 硬件要求高：由於 zmqRemoteAPI 需要在 CoppeliaSim 中啟用遠程 API 服務器，並且需要在 Python 環境中建立 ZeroMQ socket 對象進行通訊，對硬件要求較高，特別是對於低端的硬件平台可能會造成性能瓶頸。 \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n', 'tags': '', 'url': '有關 CoppeliaSim zmqRemoteAPI 問題.html'}, {'title': 'W11', 'text': '\n 我們這組是利用老師之前給的紅綠機器人的檔案來更改，把PJ1的場景加入PJ2中，在兩個球門中加上感測器，並加上記分板程式。 \n function sysCall_init()\n    score1 = 0\n    \n    sensor = sim.getObject(\'./sensor\')\n    xml = [[\n        <ui title="Scoreboard" closeable="false" resizable="false" style="plastique">\n        <label text="Score:" style="* {background-color: #808080; color: green; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px; }" id="10"/>\n        <label text="0" style="* {background-color: #FFF; color: #000000; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px;}" id="30"/>\n     \n        </ui>\n    ]]\n    ui = simUI.create(xml)\n    simUI.setPosition(ui, 0,0, true)\n    bubbleRob1 = sim.getObject(\'/bubbleRob1\')\n    ball = sim.getObject(\'/ball\')\n    bubbleRob2 = sim.getObject(\'/bubbleRob2\')\n    initialPosition1 = sim.getObjectPosition(bubbleRob1, -1)\n    initialOrientation1 = sim.getObjectOrientation(bubbleRob1, -1)\n    initialPosition2 = sim.getObjectPosition(bubbleRob2, -1)\n    initialOrientation2 = sim.getObjectOrientation(bubbleRob2, -1)\n    initialballPosition = sim.getObjectPosition(ball, -1)\n    initialballOrientation = sim.getObjectOrientation(ball, -1)\n\nend\n\n\nfunction sysCall_actuation()\n    --simUI.setLabelText(ui, 30, tostring(sim.getFloatSignal("myVariable")))\n    result=sim.readProximitySensor(sensor)\n    if(score1<99)then\n        if(result>0)then\n            score2 = score1+1\n            simUI.setLabelText(ui, 30, tostring(score2))\n\n            sim.setObjectPosition(bubbleRob1, -1, initialPosition1)\n            sim.setObjectOrientation(bubbleRob1, -1, initialOrientation1)\n            sim.setObjectPosition(bubbleRob2, -1, initialPosition2)\n            sim.setObjectOrientation(bubbleRob2, -1, initialOrientation2)\n            sim.setObjectPosition(ball, -1, initialballPosition)\n            sim.setObjectOrientation(ball, -1, initialballOrientation)\n\n            score1=score2\n        end\n    else\n        sim.pauseSimulation()\n    end\nend \n \n 新場景 \n \n \n 兩台電腦連線: \n 將下圖螢光筆位置改為另一台電腦IP \n \n \n 場景 \n 綠球控制 \n 紅球控制', 'tags': '', 'url': 'W11.html'}, {'title': 'h2', 'text': '40923235:回答teams問題，模擬coppeliasim足球機器人，尋找製作記分板方式。自評分數:60 \n 40923130:目前做了Brython亂數，建立場景，用鍵盤控制機器人，加入記分板 自評:60', 'tags': '', 'url': 'h2.html'}, {'title': 'pull request', 'text': '先fork再到新建倉儲的http複製後貼到.git/config中，內容轉完靜態後，到倉儲點選contribution後持續點選綠色的按鈕。', 'tags': '', 'url': 'pull request.html'}]};
>>>>>>> 1fcf7bd126f477e0dab110af20a3531159f462a2
